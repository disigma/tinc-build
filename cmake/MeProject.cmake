# Parse the project name and project version from the given project string.
function(me_parse_project project _name _subproject _version)
  string(REGEX MATCHALL "[^-]+" parts ${project})
  list(GET parts -1 version)
  list(REMOVE_AT parts -1)
  set(name)
  foreach(part ${parts})
    set(name ${name}-${part})
  endforeach()
  string(SUBSTRING ${name} 1 -1 name)
  if(name MATCHES "\([^\\.]+\)\\.\(.+\)")
    set(${_subproject} ${CMAKE_MATCH_1} PARENT_SCOPE)
    set(${_name} ${CMAKE_MATCH_2} PARENT_SCOPE)
  else()
    set(${_subproject} PARENT_SCOPE)
    set(${_name} ${name} PARENT_SCOPE)
  endif()
  set(${_version} ${version} PARENT_SCOPE)
endfunction(me_parse_project)

macro(me_project project)
  set(X_OPTIONS 3RD ALIAS)
  cmake_parse_arguments(X "${X_OPTIONS}" "${X_SINGLES}" "${X_MULTIS}" ${ARGN})
  if(CMAKE_SCRIPT_MODE_FILE)
    if(X_3RD)
      set(ENV{ALL} 1)
    endif()
    if(NOT X_ALIAS)
      include(MeMakefile)
      if(EXISTS ${ME_SOURCE_DIR}/main.cpp)
        set(ME_INSTALL ON)
      elseif(EXISTS ${ME_SOURCE_DIR}/dllmain.cpp)
        set(ME_INSTALL ON)
      endif()
      me_makefile_make(${project})
    endif()
    return()
  endif()
  me_project_all(${ARGV})
endmacro()

# Create a project.
#
# Params for all projects:
#
# * 3RD: Create a third-party project.
# * NO_PIC: Do not set `CMAKE_POSITION_INDEPENDENT_CODE`.
# * NO_CXX14: Do not set `CMAKE_CXX_STANDARD` to 14.
# * DEPENDS: List of projects that this project depends on.
# * LIBS: List of libraries required for this project on linking.
# * TEST_DEPENDS: List of projects that test projects depends on.
# * TEST_LIBS: List of libraries required for test projects on linking.
# * SOURCE_DIR: The source folder of this project.
#
# Params for third-party projects: - See me_project_3rd.
#
# The following variables may be set by this function:
#
# * ME_PROJECT
# * ME_PROJECT_NAME
# * ME_PROJECT_VERSION
# * ME_SOURCE_DIR
# * ME_TEST_DIR
# * ME_BUILD_DIR
# * ME_INSTALL_PREFIX
# * ME_DEPENDS
# * ME_PKG_CONFIG_DIR
#
# A custom output will be generated by this function:
#
# * ALWAYS: Targets that depend on this output will always be built.
function(me_project_all project)
  set(X_OPTIONS 3RD ALIAS NO_PIC NO_CXX14 NO_PC)
  set(X_SINGLES SOURCE_DIR)
  set(X_MULTIS DEPENDS LIBS TEST_DEPENDS TEST_LIBS)
  cmake_parse_arguments(X "${X_OPTIONS}" "${X_SINGLES}" "${X_MULTIS}" ${ARGN})

  if(NOT X_ALIAS)
    if(NOT X_SOURCE_DIR)
      set(X_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/sources)
    endif()

    set(ME_PROJECT ${project})
    set(ME_SOURCE_DIR ${X_SOURCE_DIR})
    set(ME_TEST_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tests)
    set(ME_BUILD_DIR ${ME_BUILD_ROOT}/${project}/build)
    set(ME_INSTALL_PREFIX ${ME_BUILD_ROOT}/${project}/install)
    me_parse_project(
      ${ME_PROJECT} ME_PROJECT_NAME ME_SUBPROJECT ME_PROJECT_VERSION
    )

    set(ME_PROJECT ${ME_PROJECT} PARENT_SCOPE)
    set(ME_PROJECT_NAME ${ME_PROJECT_NAME} PARENT_SCOPE)
    set(ME_PROJECT_VERSION ${ME_PROJECT_VERSION} PARENT_SCOPE)
    set(ME_SOURCE_DIR ${ME_SOURCE_DIR} PARENT_SCOPE)
    set(ME_TEST_DIR ${ME_TEST_DIR} PARENT_SCOPE)
    set(ME_BUILD_DIR ${ME_BUILD_DIR} PARENT_SCOPE)
    set(ME_DEPENDS ${X_DEPENDS} PARENT_SCOPE)
    set(ME_INSTALL_PREFIX ${ME_INSTALL_PREFIX} PARENT_SCOPE)
  endif()

  add_custom_command(OUTPUT ALWAYS COMMENT "")

  if(NOT X_3RD)
    # TODO: Check if these variables will affect the imported projects.
    if(NOT X_NO_PIC)
      set(CMAKE_POSITION_INDEPENDENT_CODE ON)
    endif()
    if(NOT X_NO_CXX14)
      set(CMAKE_CXX_STANDARD_REQUIRED ON)
      set(CMAKE_CXX_STANDARD 14)
    endif()

    me_build_lib()
    me_build_dll()
    me_build_exe()
    me_build_test()
  endif()

  # Clear these properties to avoid affecting the projects that will be
  # imported.
  set_property(DIRECTORY PROPERTY DEFINITIONS)
  set_property(DIRECTORY PROPERTY COMPILE_DEFINITIONS)
  set_property(DIRECTORY PROPERTY COMPILE_OPTIONS)
  set_property(DIRECTORY PROPERTY INCLUDE_DIRECTORIES)
  set_property(DIRECTORY PROPERTY LINK_DIRECTORIES)
  set_property(DIRECTORY PROPERTY LINK_OPTIONS)

  me_import(${X_DEPENDS})

  if(NOT X_3RD)
    add_custom_target(${ME_PROJECT}- DEPENDS ${ME_PROJECT})
    target_include_directories(${ME_PROJECT} PUBLIC ${ME_IMPORTED_INCLUDES})
    if(TARGET ${ME_PROJECT}-exe)
      add_dependencies(${ME_PROJECT}- ${ME_PROJECT}-exe)
      target_include_directories(
        ${ME_PROJECT}-exe PUBLIC ${ME_IMPORTED_INCLUDES}
      )
    endif()
    if(TARGET ${ME_PROJECT}-dll)
      add_dependencies(${ME_PROJECT}- ${ME_PROJECT}-dll)
      target_include_directories(
        ${ME_PROJECT}-dll PUBLIC ${ME_IMPORTED_INCLUDES}
      )
    endif()
    if(TARGET ${ME_PROJECT}-test)
      add_dependencies(${ME_PROJECT}- ${ME_PROJECT}-test)
      target_include_directories(
        ${ME_PROJECT}-test PUBLIC ${ME_IMPORTED_INCLUDES}
      )
    endif()
  endif()

  # Set ME_PKG_CONFIG_DIR for third-party projects.
  if(X_3RD AND NOT X_NO_PC AND NOT X_ALIAS)
    set(X_PC_DIR)
    set(ME_PKG_CONFIG_DIR)
    foreach(depend ${X_DEPENDS})
      if(${depend}-PREFIX)
        list(APPEND X_PC_DIR ${${depend}-PC_DIR})
      endif()
    endforeach()
    if(X_PC_DIR)
      list(REMOVE_DUPLICATES X_PC_DIR)
    endif()
    foreach(PC_DIR ${X_PC_DIR})
      set(ME_PKG_CONFIG_DIR ${ME_PKG_CONFIG_DIR}:${PC_DIR})
    endforeach()
    list(
      APPEND X_PC_DIR #
      ${ME_INSTALL_PREFIX}/lib/pkgconfig #
      ${ME_INSTALL_PREFIX}/share/pkgconfig
    )
    set(${project}-PC_DIR ${X_PC_DIR} CACHE STRING ${project}-PC_DIR FORCE)
    set(ME_PKG_CONFIG_DIR ${ME_PKG_CONFIG_DIR} PARENT_SCOPE)
  elseif(X_3RD AND NOT X_NO_PC)
    set(
      ${project}-PC_DIR ${${ME_PROJECT}-PC_DIR} #
      CACHE STRING ${project}-PC_DIR FORCE
    )
  endif()

  if(X_3RD)
    me_project_3rd(${project} ${ARGN})
    return()
  endif()

  target_link_libraries(${ME_PROJECT} ${X_DEPENDS} ${X_LIBS})
endfunction(me_project_all)

# Create a third-party project.
#
# * META: Create a meta project (with no targets, usually used by alias
#   projects).
# * ALIAS: Create an alias project (i.e. a library built by another project).
# * SHARED: Create a shared library, otherwise the target will be a static
#   library.
# * NO_PC: Do not generate the ME_PKG_CONFIG_DIR variable.
# * LIBNAME: Override the default library name (i.e. project name).
# * LIB: Override the default library name (full filename).
# * LIB_DIR: Override the default installation directory of libraries.
# * MAKE: Specify the custom target that build the project, default is 'make',
#   which added by me_make().
# * INCLUDES: Specify the include directories relative to the install prefix.
#
# A variable will be exported by this function:
#
# * <project>-PREFIX: Install prefix of <project>.
# * <project>-LIBS: Installed libraries of <project>.
function(me_project_3rd project)
  set(X_OPTIONS META ALIAS SHARED)
  set(X_SINGLES LIB LIBNAME LIB_DIR MAKE)
  set(X_MULTIS DEPENDS LIBS INCLUDES)
  cmake_parse_arguments(X "${X_OPTIONS}" "${X_SINGLES}" "${X_MULTIS}" ${ARGN})

  if(NOT X_LIBNAME)
    me_parse_project(${project} X_LIBNAME X_SUBPROJECT X_VERSION)
    if(X_ALIAS)
      set(X_LIBNAME ${X_SUBPROJECT})
    endif()
  endif()

  if(X_SHARED)
    set(X_LIBTYPE SHARED)
  else()
    set(X_LIBTYPE STATIC)
  endif()

  if(NOT X_LIB)
    set(X_LIB_PREFIX ${CMAKE_${X_LIBTYPE}_LIBRARY_PREFIX})
    set(X_LIB_SUFFIX ${CMAKE_${X_LIBTYPE}_LIBRARY_SUFFIX})
    set(X_LIB ${X_LIB_PREFIX}${X_LIBNAME}${X_LIB_SUFFIX})
  endif()

  if(NOT X_LIB_DIR)
    set(X_LIB_DIR lib)
  endif()

  if(NOT X_INCLUDES)
    if(NOT X_ALIAS)
      set(X_INCLUDES include)
    else()
      set(X_INCLUDES ${${ME_PROJECT}-INCLUDES})
    endif()
  endif()

  if(NOT X_MAKE)
    set(X_MAKE make)
  endif()

  if(NOT X_ALIAS)
    add_custom_target(${ME_PROJECT}- DEPENDS ${X_DEPENDS} ${X_MAKE})
  endif()

  add_library(${project} ${X_LIBTYPE} IMPORTED GLOBAL)

  if(NOT X_META)
    set(X_IMPORTED_LOCATION ${ME_INSTALL_PREFIX}/${X_LIB_DIR}/${X_LIB})
    set(${project}-LIBS ${X_IMPORTED_LOCATION} CACHE PATH ${project}-LIBS)
    list(APPEND ${ME_PROJECT}-LIBS ${X_IMPORTED_LOCATION})
    list(REMOVE_DUPLICATES ${ME_PROJECT}-LIBS)
    set_target_properties(
      ${project} PROPERTIES IMPORTED_LOCATION ${X_IMPORTED_LOCATION}
    )
    foreach(include ${X_INCLUDES})
      set_property(
        TARGET ${project} APPEND #
        PROPERTY INCLUDE_DIRECTORIES ${ME_INSTALL_PREFIX}/${include}
      )
    endforeach()
    target_link_libraries(${project} INTERFACE ${X_DEPENDS} ${X_LIBS})
  endif()

  add_dependencies(${project} ${ME_PROJECT}-)

  set(${project}-PREFIX ${ME_INSTALL_PREFIX} CACHE PATH ${project}-PREFIX)
  set(${project}-INCLUDES ${X_INCLUDES} CACHE PATH ${project}-INCLUDES)
  set(
    ${ME_PROJECT}-LIBS ${${ME_PROJECT}-LIBS} #
    CACHE INTERNAL ${ME_PROJECT}-LIBS FORCE
  )
endfunction(me_project_3rd)
